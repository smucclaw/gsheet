* musings

** Global Facts

#+begin_src haskell
[]
#+end_src

** Class Hierarchy



** The entire classgraph

#+begin_src haskell
[]
#+end_src

** Symbol Table

we know about the following scopes



** the Rule Decision Graph

#+begin_example
1:[MTT "Person"]->[]

#+end_example

** Decision Roots

rules which are not just RuleAlises, and which are not relied on by any other rule

#+begin_src haskell
[
    [ MTT "Person" ]
]
#+end_src

*** Nubbed, Exposed, Decision Roots

maybe some of the decision roots are identical and don't need to be repeated; so we nub them

**** Decision Root 1

- [Person]

***** grpval

#+begin_src haskell
Just
    ( All Nothing
        [ Leaf "Person walks"
        , Any Nothing
            [ Leaf "Person eats"
            , Leaf "Person drinks"
            ]
        ]
    )
#+end_src

***** head uniqrs

#+begin_src haskell
Regulative
    { subj = Leaf
        (
            ( MTT "Person" :| []
            , Nothing
            ) :| []
        )
    , rkeyword = REvery
    , who = Just
        ( All Nothing
            [ Leaf
                ( RPMT
                    [ MTT "walks" ]
                )
            , Any Nothing
                [ Leaf
                    ( RPMT
                        [ MTT "eats" ]
                    )
                , Leaf
                    ( RPMT
                        [ MTT "drinks" ]
                    )
                ]
            ]
        )
    , cond = Nothing
    , deontic = DMust
    , action = Leaf
        (
            ( MTT "sing" :| []
            , Nothing
            ) :| []
        )
    , temporal = Nothing
    , hence = Nothing
    , lest = Nothing
    , rlabel = Nothing
    , lsource = Nothing
    , srcref = Just
        ( SrcRef
            { url = "./temp/workdir/00c5f231-8844-4f15-8723-20b6f5bd0aa3/1Wgt73WV8vU9Ap4xTLLPZMvNKz1Q_SV_v7YeXYtaX7nY/237516042/20230606T074118.398674Z.csv"
            , short = "./temp/workdir/00c5f231-8844-4f15-8723-20b6f5bd0aa3/1Wgt73WV8vU9Ap4xTLLPZMvNKz1Q_SV_v7YeXYtaX7nY/237516042/20230606T074118.398674Z.csv"
            , srcrow = 2
            , srccol = 1
            , version = Nothing
            }
        )
    , upon = Nothing
    , given = Nothing
    , having = Nothing
    , wwhere = []
    , defaults = []
    , symtab = []
    }
#+end_src

***** getAndOrTree (head uniqrs)

#+begin_src haskell
Just
    ( All Nothing
        [ Leaf "Person walks"
        , Any Nothing
            [ Leaf "Person eats"
            , Leaf "Person drinks"
            ]
        ]
    )
#+end_src

***** getBSR [head uniqrs]

#+begin_src haskell
[ All Nothing
    [ Leaf
        ( RPMT
            [ MTT "Person"
            , MTT "walks"
            ]
        )
    , Any Nothing
        [ Leaf
            ( RPMT
                [ MTT "Person"
                , MTT "eats"
                ]
            )
        , Leaf
            ( RPMT
                [ MTT "Person"
                , MTT "drinks"
                ]
            )
        ]
    ]
]
#+end_src

***** expandBSR

#+begin_src haskell
[ All Nothing
    [ Leaf
        ( RPMT
            [ MTT "Person"
            , MTT "walks"
            ]
        )
    , Any Nothing
        [ Leaf
            ( RPMT
                [ MTT "Person"
                , MTT "eats"
                ]
            )
        , Leaf
            ( RPMT
                [ MTT "Person"
                , MTT "drinks"
                ]
            )
        ]
    ]
]
#+end_src



** qaHornsR

*** [MTT "Person"]

#+begin_src haskell
All Nothing
    [ Leaf
        ( RPMT
            [ MTT "Person"
            , MTT "walks"
            ]
        )
    , Any Nothing
        [ Leaf
            ( RPMT
                [ MTT "Person"
                , MTT "eats"
                ]
            )
        , Leaf
            ( RPMT
                [ MTT "Person"
                , MTT "drinks"
                ]
            )
        ]
    ]
#+end_src

** qaHornsT

*** [MTT "Person"]

#+begin_src haskell
All Nothing
    [ Leaf "Person walks"
    , Any Nothing
        [ Leaf "Person eats"
        , Leaf "Person drinks"
        ]
    ]
#+end_src

** expandedRules

(ahem, they're actually the same as unexpanded, not showing)

** getAndOrTrees, direct

*** Person

#+begin_src haskell
Just
    ( All Nothing
        [ Leaf "Person walks"
        , Any Nothing
            [ Leaf "Person eats"
            , Leaf "Person drinks"
            ]
        ]
    )
#+end_src

** Things that are RuleAliases



** default markings

terms annotated with TYPICALLY so we tell XPile targets what their default values are

#+begin_src haskell
Marking
    { getMarking = fromList [] }
#+end_src

** symbol tables (~scopetable l4i~)



** class tables (~classtable l4i~)

#+begin_src haskell
CT
    ( fromList [] )
#+end_src



** The original rules (~origrules l4i~)

*** [Person]

#+begin_src haskell
Regulative
    { subj = Leaf
        (
            ( MTT "Person" :| []
            , Nothing
            ) :| []
        )
    , rkeyword = REvery
    , who = Just
        ( All Nothing
            [ Leaf
                ( RPMT
                    [ MTT "walks" ]
                )
            , Any Nothing
                [ Leaf
                    ( RPMT
                        [ MTT "eats" ]
                    )
                , Leaf
                    ( RPMT
                        [ MTT "drinks" ]
                    )
                ]
            ]
        )
    , cond = Nothing
    , deontic = DMust
    , action = Leaf
        (
            ( MTT "sing" :| []
            , Nothing
            ) :| []
        )
    , temporal = Nothing
    , hence = Nothing
    , lest = Nothing
    , rlabel = Nothing
    , lsource = Nothing
    , srcref = Just
        ( SrcRef
            { url = "./temp/workdir/00c5f231-8844-4f15-8723-20b6f5bd0aa3/1Wgt73WV8vU9Ap4xTLLPZMvNKz1Q_SV_v7YeXYtaX7nY/237516042/20230606T074118.398674Z.csv"
            , short = "./temp/workdir/00c5f231-8844-4f15-8723-20b6f5bd0aa3/1Wgt73WV8vU9Ap4xTLLPZMvNKz1Q_SV_v7YeXYtaX7nY/237516042/20230606T074118.398674Z.csv"
            , srcrow = 2
            , srccol = 1
            , version = Nothing
            }
        )
    , upon = Nothing
    , given = Nothing
    , having = Nothing
    , wwhere = []
    , defaults = []
    , symtab = []
    }
#+end_src

**** local variables

#+begin_src haskell
[]
#+end_src