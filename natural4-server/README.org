* Build with Docker

This project can now be built with Docker, there are two Dockerfiles, one for dev and one for prod.

To build this in dev
#+begin_example
docker build -f ./Dockerfile.dev -t natural4-server:dev .
docker run natural4-server:dev
#+end_example

To build this in prod
#+begin_example
docker build -f ./Dockerfile.prod -t natural4-server:prod .
docker run -v /etc/letsencrypt:/etc/letsencrypt -p {your_port}:8080 natural4-server:prod
#+end_example

Note that we tag each docker image with their respective ~dev~ or ~prod~ builds. This helps us differentiate which one to run. The production image is intended to be ran on the production server. It will need the letsencrypt certificates. Note that it'll run on ~8080~ within the docker container. We will use expose our individually assigned port, that maps to ~8080~. For instance, if my assigned port is ~8500~, I will run

#+begin_example
docker run -v /etc/letsencrypt:/etc/letsencrypt -p 8500:8080 natural4-server:prod
#+end_example

* Installing the python stuff 

There's a poetry config that you can use in the short term (in the long term, we'll probably try to move to ~nix~ at least partially), and which was adapted from the config Joe had around May 24. 

To use this:
0. Install ~pyenv~ if you want to be able to easily toggle between python versions, and follow the docs for how to use ~pyenv~ with ~poetry~. The rest of the instructions won't talk about pyenv.

1. Install poetry in your user account, by following the instructions at ~https://python-poetry.org/docs/~. It will probably be better to install poetry with python 3.11. As of end May 2023, the following should work: ~curl -sSL https://install.python-poetry.org | python3.11 -~

2. Then to install the dependencies, navigate to the dir with the poetry files (i.e., this subdir) and run

#+begin_example
export PYTHON_KEYRING_BACKEND=keyring.backends.null.Keyring
# you'll probably need this for the server
poetry shell

poetry install
#+end_example

You can activate the virtual environment with ~poetry shell~. Or to run the scripts, you can do ~poetry run~. See the docs (https://python-poetry.org/docs/) for more info.

If you run into issues on the server with poetry trying to use python3.8 instead of python3.11 (which is what is specified in the .toml), you can try

#+begin_example
poetry env use /usr/bin/python3.11
poetry shell
#+end_example

To check what python the virtual env is using, do ~poetry env info~.

* Invocation

#+begin_example
~/src/smucclaw/gsheet/pyrest$ gunicorn wsgi:app -c gunicorn.conf.py
#+end_example

* DevMode

If you want to run a dev version of the Google Apps Script and pyrest codebase, you can launch a new gunicorn instance on, say, port 8081.

If somewhere in the top ten lines of the spreadsheet you have something like this, it will use that port instead

#+begin_example
// live updates TRUE      devMode port 8081
#+end_example

If you're actively editing the spreadsheet and the redraws are slowing you
down, set live updates to FALSE.

* How Slots Work

Suppose you configure your ~gunicorn.conf.py~ to run with
- startport :: 8000
- bind :: 0.0.0.0:8888

hello.py will call v8k, and v8k will launch ~npm run serve~ clones of the ~[[../vue-pure-pdpa/][vue-pure-pdpa]]~ repo.

This will set up the following listening servers:

| port | listener                  | description                                                                                         |
|------+---------------------------+-----------------------------------------------------------------------------------------------------|
| 8888 | gunicorn running hello.py | If your spreadsheet has devMode port, Code.gs will try to hit the pyrest API endpoint on this port. |
| 8000 | npm run serve             | managed by v8k                                                                                      |
| 8001 | npm run serve             | managed by v8k                                                                                      |
| 8002 | npm run serve             | managed by v8k                                                                                      |
| 8003 | npm run serve             | managed by v8k                                                                                      |
| 8004 | npm run serve             | managed by v8k                                                                                      |
| 8005 | npm run serve             | managed by v8k                                                                                      |
| 8006 | npm run serve             | managed by v8k                                                                                      |
| 8007 | npm run serve             | managed by v8k                                                                                      |
| 8008 | npm run serve             | managed by v8k                                                                                      |

If the spreadsheet does not have a ~devMode port~ the default is 8080.

The AWS instance is configured to open ports 8000 to 9000 so you can pick your own combination of ~bind~ port and ~startport~.

The convention is to have the ~bind~ port immediately below the ~startport~, i.e.

| port | listener                                     |
|------+----------------------------------------------|
| 8200 | gunicorn's bind port                         |
| 8201 | the startport configured in gunicorn.conf.py |

If there are multiple users on the server, you can each agree amongst yourselves to each squat on a different set of 10 ports.

By default, the v8k poolsize is 9.

If you need a poolsize greater than 9, we will need to tweak the source code:
- in gunicorn.conf.py to set a ~poolsize~ parameter
- in hello.py to pass that parameter to v8k.

* SSL background

1. did Let's Encrypt with CertBot [2022-07-10 Sun] https://certbot.eff.org/instructions?ws=other&os=ubuntufocal

2. set up a cname from cclaw.legalese.com to the AWS instance

3. run gunicorn with certfile and keyfile
   https://stackoverflow.com/questions/7406805/running-gunicorn-on-https

4. now the SVG and PNG should work in the sidebar main.html
   

* The User Experience, Broken Down Step By Step

see architecture.dot for illustration

* Invoke from command-line

#+begin_src bash
  curl localhost:8020/post -F uuid="23fcb41d-4438-45f4-976e-16174109df02" -F spreadsheetId="1GdDyNl6jWaeSwY_Ao2sA8yahQINPcnhRh9naGRIDGak" -F sheetId="1206725099" -F "csvString=<$filename.csv"
#+end_src
